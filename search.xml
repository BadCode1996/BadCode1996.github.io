<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java面试题 -- MySQL面试题</title>
      <link href="/2020/06/16/Java%E9%9D%A2%E8%AF%95%E9%A2%98-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/06/16/Java%E9%9D%A2%E8%AF%95%E9%A2%98-MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库类型"><a href="#数据库类型" class="headerlink" title="数据库类型"></a>数据库类型</h2><h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><p>​        关系型数据库是建立在关系模型上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。简单说，关系型数据库就是由多张可以互相连接的表组成的数据库。</p><p><strong>优点：</strong></p><pre><code>1. 都是使用表结构，格式一致，方便维护 2. 使用通用的SQL语言操作，使用方便，可用于复杂查询 3. 数据库存储在磁盘，安全</code></pre><p><strong>缺点：</strong></p><pre><code>1. 读写性能比较差，无法满足海量数据的高效率读写； 2. 不节省空间，因为建立在关系模型上，就需要遵循某些规则，比如数据库中的空值仍要分配空间 3. 固定的表结构，灵活性低</code></pre><p><strong>常见的关系型数据库有哪些：</strong></p><p>​    <strong>MySQL</strong>、<strong>Oracle</strong>、<strong>SQL Server</strong>、 PostgreSQL 等</p><h3 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h3><p>​        非关系型数据库又称为NoSQL（not only SQL），意为不仅仅是SQL。通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。</p><p><strong>优点：</strong></p><pre><code>1. 非关系型数据库存储数据的格式可以是key-value形式、文档形式、图片形式等，使用灵活，应用场景广泛，而关系型数据库只支持基本类型。 2. 速度快，效率高，NoSQL可以使用硬盘或随机存储器作为载体，而关系型数据库只能保存到磁盘。 3. 海量数据的维护和处理很轻松。 4. 非关系型数据库具有扩展简单、高并发、高稳定性、成本低廉的优势。 5. 可以实现数据的分布式处理。</code></pre><p><strong>缺点：</strong></p><pre><code>1. 非关系型数据库暂时没有提供SQL支持，学习和使用成本较高。 2. 非关系型数据库没有事务处理，没有保证数据的完整性和安全性。适合海量数据，但是不一定安全。 3. 功能没有关系型数据库完善</code></pre><p><strong>常见的非关系型数据库有哪些：</strong></p><p>​    <strong>Redis</strong>、<strong>MongoDB</strong>、Neo4j、Memcached、MemcacheDB、HBase等</p><h2 id="数据库引擎"><a href="#数据库引擎" class="headerlink" title="数据库引擎"></a>数据库引擎</h2><p>​    MySQL支持的数据引擎有 <strong>InnoDB</strong>、<strong>MyISAM</strong>等。</p><p>​    可以使用 <strong>SHOW ENGINES</strong>; 查看<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/SevenKiss/imgPicGo/image/20200704034727.png" alt=""></p><p><strong>在这里可以看出MySQL默认使用InnoDB引擎</strong></p><p> Support 列的值表示某种引擎是否能使用 ，<strong>YES</strong>表示可用，<strong>NO</strong>不可用，<strong>DEFAULT</strong>表示默认</p><table><thead><tr><th align="center"><strong>存储引擎</strong></th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">InnoDB</td><td align="center">具备外键支持功能的事务处理引擎</td></tr><tr><td align="center">MyISAM</td><td align="center">主要的非事务处理存储引擎</td></tr><tr><td align="center">MEMORY</td><td align="center">置于内存的表</td></tr><tr><td align="center">ARCHIVE</td><td align="center">用于数据存档的引擎，数据被插入后就不能在修改了，且不支持索引。</td></tr><tr><td align="center">CSV</td><td align="center">在存储数据时，会以逗号作为数据项之间的分隔符。</td></tr><tr><td align="center">BLACKHOLE</td><td align="center">会丢弃写操作，该操作会返回空内容。</td></tr><tr><td align="center">FEDERATED</td><td align="center">将数据存储在远程数据库中，用来访问远程表的存储引擎。</td></tr><tr><td align="center">MERGE</td><td align="center">用来管理由多个 MyISAM 表构成的表集合</td></tr><tr><td align="center">NDB</td><td align="center">MySQL 集群专用存储引擎</td></tr></tbody></table><h2 id="常用数据库"><a href="#常用数据库" class="headerlink" title="常用数据库"></a>常用数据库</h2><pre><code>### 0. 常用数据库排名</code></pre><p> <strong><em>\</em><a href="https://db-engines.com/en/ranking" target="_blank" rel="noopener">DB-Engines</a>**</strong>  <strong>2020年6月全球数据库排行</strong> </p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/SevenKiss/imgPicGo/image/20200704035455.png" alt=""></p><p><strong>关系型数据库排名</strong></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/SevenKiss/imgPicGo/image/20200704035501.png" alt=""></p><p><strong>非关系型数据库排名</strong></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/SevenKiss/imgPicGo/image/20200704035505.png" alt=""></p><h3 id="关系型数据库-1"><a href="#关系型数据库-1" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><ol><li><p>Oracle</p><p><strong>Oracle</strong>是甲骨文的一款关系型数据库管理系统，在数据库领域一直处于领先的地位， 是目前世界上流行的关系型数据库之一 ，是一种高效率、可靠性好、适应高吞吐量的数据库方案。</p><p><strong>优点：</strong></p><pre><code>1. 可移植性好，可以在所有主流平台运行，完全支持所有工业化标准。 2. 获得最高级认证级别的ISO标准认证，安全性高。 3. 与其他数据库相比，Oracle性能高 4. 多层次网络计算，支持多种标准，可以用ODBC、JDBC、OCI等网络客户连接 5. 完全向下兼容，因此被广泛使用，且风险低</code></pre><p><strong>缺点：</strong></p><pre><code>1. 对硬件的要求高 2. 价格昂贵 3. 管理维护麻烦 4. 操作比较复杂</code></pre></li><li><p>MySQL</p><p> MySQL 是一种开放源代码的关系型数据库管理系统 ，在WEB应用方面，MySQL是最好的应用软件之一</p><p><strong>优点：</strong></p><pre><code>1. 性能卓越服务稳定，很少出现宕机。2. 开源，自主性强，使用成本低3.  历史悠久、社区及用户非常活跃，遇到问题，可以很快获取到帮助。 4.  件体积小，安装使用简单，并且易于维护，安装及维护成本低。 5.  支持多种操作系统，提供多种 API 接口，支持多种开发语言。 </code></pre><p><strong>缺点：</strong></p><pre><code>1.  ySQL 最大的缺点是其安全系统，主要是复杂而非标准，只有调用 mysqladmin 来重读用户权限才会发生改变。  2.   MySQL 不允许调试存储过程，开发和维护存储过程很难。  3.   MySQL 不支持热备份。  4.   MySQL 的价格随平台和安装方式变化。 </code></pre></li></ol><h3 id="非关系型数据库-1"><a href="#非关系型数据库-1" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h3><ol><li><p>Redis</p><p> <a href="http://c.biancheng.net/redis/" target="_blank" rel="noopener">Redis</a> 是当前互联网世界最为流行的 <a href="http://c.biancheng.net/nosql/" target="_blank" rel="noopener">NoSQL</a>（Not Only SQL）数据库。 </p><ol><li><p>响应快速</p><p> Redis 响应非常快，每秒可以执行大约 110 000 个写入操作，或者 81 000 个读操作，其速度远超数据库。如果存入一些常用的数据，就能有效提高系统的性能。 </p></li><li><p>支持6中数据类型</p><p> 它们是<strong>字符串</strong>、<strong>哈希结构</strong>、<strong>列表</strong>、<strong>集合</strong>、<strong>可排序集合</strong>和<strong>基数</strong>。比如对于字符串可以存入一些 Java基础数据类型，哈希可以存储对象，列表可以存储 List 对象等。这使得在应用中很容易根据自己的需要选择存储的数据类型，方便开发。 </p><p> 对于 Redis 而言，虽然只有 6 种数据类型，但是有两大好处：一方面可以满足存储各种数据结构体的需要；另外一方面数据类型少，使得规则就少，需要的判断和逻辑就少，这样读/写的速度就更快。 </p></li><li><p>操作都是原子的</p><p> 所有 Redis 的操作都是原子的，从而确保当两个客户同时访问 Redis 服务器时，得到的是更新后的值（最新值）。  在需要高并发的场合可以考虑使用 Redis 的事务，处理一些需要锁的业务。</p></li></ol></li></ol><h2 id="MySQL数据库的事务特性"><a href="#MySQL数据库的事务特性" class="headerlink" title="MySQL数据库的事务特性"></a>MySQL数据库的事务特性</h2><h3 id="事务概念"><a href="#事务概念" class="headerlink" title="事务概念"></a>事务概念</h3><p>​    事务就是一个程序执行单元，里面的操作要么全部执行完成，要么全部都不执行</p><h3 id="事务特性（ACID）"><a href="#事务特性（ACID）" class="headerlink" title="事务特性（ACID）"></a>事务特性（ACID）</h3><p>​    事务有4个非常重要的特性</p><pre><code>1. Atomicity 原子性 ：事务是不可分割的整体，所有操作要么全做，要么全不做；只要事务中有一个操作出错，回滚到事务开始前状态，即之前已经执行的操作无效 2. Consistency 一致性：事务执行后，从一个一致性状态到另一个一致性状态；比如A向B转账，（A、B总金额是一个一致性状态）不可能出现A扣了钱，但B没收到 3. Isolation 隔离性：多个事务之间相互隔离，互不干扰 4. Durablity 持久性：事务完成后，对数据库的更改是永久保存的，不能回滚</code></pre><h3 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h3><pre><code>1. 脏读：一个事务读取到了另一个事务未提交的数据 2. 幻读：多次读取到的结果不一致。（被另一个事物新增 或 删除了记录） 3. 不可重复读：一个事务多次读取同一数据，得到了不同的值。（被另一个事务更新了）</code></pre><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ol><li><p>读未提交（read-uncommitted）</p></li><li><p>读已提交（read-committed）解决脏读</p></li><li><p>可重复读（Repeatable read）解决脏读、不可重复读</p></li><li><p>串行化（Serializable）解决脏读，不可重复读、幻读</p><p>MySQL默认隔离级别是<strong>Repeatable read</strong>，级别越高，性能就越低</p><ol><li>查看当前会话隔离级别<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @@tx_isolation;</span><br></pre></td></tr></table></figure></li><li>查看系统当前隔离级别<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @@global.tx_isolation;</span><br></pre></td></tr></table></figure></li><li>设置当前会话隔离级别<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">session</span> <span class="keyword">transaction</span> isolatin <span class="keyword">level</span> repeatable <span class="keyword">read</span>;</span><br></pre></td></tr></table></figure></li><li>设置系统当前隔离级别<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> <span class="keyword">transaction</span> <span class="keyword">isolation</span> <span class="keyword">level</span> repeatable <span class="keyword">read</span>;</span><br></pre></td></tr></table></figure></li></ol><p>Oracle默认隔离级别是<strong>read-committed</strong>，读已提交<br>Oracle数据库支持READ COMMITTED 和 SERIALIZABLE这两种事务隔离级别。</p><ol><li>查看系统默认事务隔离级别,也是当前会话隔离级别<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 首先创建一个事务</span></span><br><span class="line"><span class="keyword">declare</span></span><br><span class="line">    trans_id <span class="built_in">Varchar2</span>(<span class="number">100</span>);</span><br><span class="line">   <span class="keyword">begin</span></span><br><span class="line">    trans_id := dbms_transaction.local_transaction_id( <span class="literal">TRUE</span> );</span><br><span class="line">   <span class="keyword">end</span>; </span><br><span class="line"><span class="comment">-- 查看事务隔离级别</span></span><br><span class="line"><span class="keyword">SELECT</span> s.sid, s.serial<span class="comment">#,</span></span><br><span class="line">    <span class="keyword">CASE</span> BITAND(t.flag, <span class="keyword">POWER</span>(<span class="number">2</span>, <span class="number">28</span>))</span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">0</span> <span class="keyword">THEN</span> <span class="string">'READ COMMITTED'</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">'SERIALIZABLE'</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">AS</span> isolation_level</span><br><span class="line"><span class="keyword">FROM</span> v$<span class="keyword">transaction</span> t</span><br><span class="line"><span class="keyword">JOIN</span> v$<span class="keyword">session</span> s <span class="keyword">ON</span> t.addr = s.taddr <span class="keyword">AND</span> s.sid = sys_context(<span class="string">'USERENV'</span>, <span class="string">'SID'</span>);</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试题 --- final、finally、finalize的区别</title>
      <link href="/2020/06/15/Java%E9%9D%A2%E8%AF%95%E9%A2%98-final%E3%80%81finally%E3%80%81finalize%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/06/15/Java%E9%9D%A2%E8%AF%95%E9%A2%98-final%E3%80%81finally%E3%80%81finalize%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ol><li><p>基本介绍</p><p>​    <strong>final</strong>是Java中的关键字，修饰符，可用来修饰属性、方法、类</p><p>1.1、修饰属性，表示修饰的属性不可更改</p><p>​    被声明为final的变量，必须在声明时给定初始值，在以后的引用中，只能使用，不能修改</p><p>1.2、修饰方法，表示修饰的方法不可被覆盖（重写）</p><p>​    被声明为final的方法只能使用，不可以修改</p><p>1.3、修饰类，表示修饰的类不可被继承</p><p>​    如果一个类被声明了final，就说明它不可能再派生出新的子类，因此，用一个类<strong>不可以同时</strong>声明为<strong>abstract抽象类</strong>和<strong>final</strong>的类</p></li><li><p>详细介绍</p><ol><li><p>修饰属性</p><p>​    如果final修饰的是基本数据类型，表示这个变量被赋予的值是不可更改的，即它是个常量；</p><p>​    如果final修饰的是一个对象，表示这个变量被赋予的引用是不可改变的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> A = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">final</span> User USER = <span class="keyword">new</span> User();</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    编译报错，被final修饰的变量或对象，初始化后都不可被再次改变</span></span><br><span class="line"><span class="comment">//    A = 20;</span></span><br><span class="line"><span class="comment">//    USER = new User();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    如果一个<strong>变量</strong>或<strong>方法参数</strong>被final修饰，就表示它只能被赋值一次，但是JVM虚拟机为变量设定的默认值不记作一次赋值。被final修饰的变量必须被初始化，初始化的几种方式：</p><p>​    1、在定义的时候初始化</p><p>​    2、可以在初始化块中初始化，不可以在静态初始化块中初始化</p><p>​    3、静态final变量可以在定义时初始化，也可以在静态初始化块中初始化，但不可以在初始化块中初始化</p><p>​    4、final变量可以在类的构造器内初始化，但是静态final不可以</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="comment">//    在定义时初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> A1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> A2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    在初始化块中初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> B1;&#123; B1 = <span class="number">10</span>; &#125;</span><br><span class="line"><span class="comment">//    public static final int B2;&#123; B2 = 10; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    在静态初始化块中初始化</span></span><br><span class="line"><span class="comment">//    public final int C1;static &#123; C1 = 10; &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> C2;<span class="keyword">static</span> &#123; C2 = <span class="number">10</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    在构造函数中初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> D1;</span><br><span class="line"><span class="comment">//    public static final int D2;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        D1 = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//        D2 = 10;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">初始化</th><th align="center">在定义时</th><th align="center">在初始化块中</th><th align="center">在静态初始化块中</th><th align="center">在构造函数中</th></tr></thead><tbody><tr><td align="center">静态常量</td><td align="center">√</td><td align="center"></td><td align="center">√</td><td align="center"></td></tr><tr><td align="center">非静态常量</td><td align="center">√</td><td align="center">√</td><td align="center"></td><td align="center">√</td></tr></tbody></table></li><li><p>修饰方法</p><p>当final修饰一个方法时，表示这个方法不可被子类重写，但还是可以继承的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"People eat meat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">eating</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"People eat meat......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*public void say()&#123;</span></span><br><span class="line"><span class="comment">        System.out.println("你好");</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student eat vegetable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">eating</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student eat vegetable......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">        student.say();  <span class="comment">//输出结果：Hello World!</span></span><br><span class="line">        student.eat();  <span class="comment">//输出结果：Student eat vegetable</span></span><br><span class="line">        student.eating();   <span class="comment">//输出结果：Student eat vegetable......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具有private权限的方法也可以用final修饰，但是由于子类无法继承private方法，因此也无法重写。</p><p>编译器在处理private方法时，是按照被final修饰的方法来处理，这样可以提高该方法被调用时的效率。</p><p>子类仍然可以定义与父类中private方法具有同样结构的同名方法，但是这并不是重写，二者并无关联</p></li></ol></li></ol><pre><code>3. 修饰类   final修饰的类不可被继承，比如String类，就是final修饰的   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">...<span class="comment">//code</span></span><br><span class="line">    ...<span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   由于abstract关键字修饰的类为抽象类，其方法为抽象方法，需要有其子类来重载实现抽象方法，因此abstract关键字和final关键字不可同时用来修饰一个类。   同理，final也不可用来修饰接口。   final修饰的类的所有方法都不可被重写，但其中没有被final修饰的变量可以被修改   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">        demo.a = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//        demo.b = 200;</span></span><br><span class="line">        System.out.println(demo.a);<span class="comment">//输出结果：100</span></span><br><span class="line">        System.out.println(demo.b);<span class="comment">//输出结果：20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>​    finally作为异常处理的一部分，只能用在try…catch语句中，并且附带着一个语句块，表示这段语句最终一定会执行，<strong>经常被用在需要释放资源的情况下</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"程序结束，finally语句块执行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">java.lang.ArithmeticException: / by zero</span></span><br><span class="line"><span class="comment">at com.demo.Demo.main(Demo.java:4)</span></span><br><span class="line"><span class="comment">程序结束，finally语句块执行</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>很多人认为finally语句块一定会执行，其实是不一定</p><ol><li><p>try/catch语句块没有执行到，程序就结束了，finally语句块无法执行</p><p>方法被返回，执行了return语句；</p><p>在try/catch之前，出现了异常，程序中断；</p></li><li><p>执行到try/catch，但Java虚拟机被终止运行</p><p>在try语句块内执行了System.exit(0); JVM终止</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//没有执行到try/catch语句块，finally不会执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//i = i / 0;</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = i/<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"程序结束，finally语句块执行"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">        <span class="keyword">int</span> test = demo.test(<span class="number">1</span>);</span><br><span class="line">        System.out.println(test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//程序中止</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.exit(<span class="number">0</span>);<span class="comment">//在try语句块中，中止程序，finally语句块无法执行</span></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"程序结束，finally语句块执行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h2><p>finalize是Object类的一个方法，它的方法定义如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>finalize()是GC（ garbagecollector 垃圾回收器）运行机制的一部分。finalize()方法是在GC清理它所丛属的对象时被调用的，如果在执行它的过程中抛出了无法捕获的异常，GC将终止这次对该对象的清理，并且该异常会被忽略，知道下一次GC开始清理这个对象时，会再次调用finalize()方法</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试题 -- ==和equals的区别</title>
      <link href="/2020/06/15/Java%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20==%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/06/15/Java%E9%9D%A2%E8%AF%95%E9%A2%98%20-%20==%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="“-”的含义"><a href="#“-”的含义" class="headerlink" title="“==”的含义"></a>“==”的含义</h3><p>在Java中，主要有两个作用</p><h4 id="比较基本数据类型（byte、short、int、long、float、double、char、boolean）"><a href="#比较基本数据类型（byte、short、int、long、float、double、char、boolean）" class="headerlink" title="比较基本数据类型（byte、short、int、long、float、double、char、boolean）"></a>比较基本数据类型（byte、short、int、long、float、double、char、boolean）</h4><p>比较值是否相等，比如两个int类型，比较的是两个变量值是否相等</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">12</span>;</span><br><span class="line">    System.out.println(a == b);<span class="comment">//输出结果：false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="比较引用数据类型（数组、类、接口）"><a href="#比较引用数据类型（数组、类、接口）" class="headerlink" title="比较引用数据类型（数组、类、接口）"></a>比较引用数据类型（数组、类、接口）</h4><p>比较的是引用地址是否相同</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">User user1 = <span class="keyword">new</span> User(<span class="string">"张三"</span>, <span class="number">20</span>);</span><br><span class="line">User user2 = <span class="keyword">new</span> User(<span class="string">"张三"</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//System.identityHashCode(Object)方法可以返回对象的内存地址</span></span><br><span class="line">System.out.println(System.identityHashCode(user1));<span class="comment">//输出结果：603742814</span></span><br><span class="line">System.out.println(System.identityHashCode(user2));<span class="comment">//输出结果：1067040082</span></span><br><span class="line"></span><br><span class="line">System.out.println(user1 == user2);<span class="comment">//输出结果：false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="“equals”的含义"><a href="#“equals”的含义" class="headerlink" title="“equals”的含义"></a>“equals”的含义</h3><p>在Java中，Object类里有equals方法，String类里也有equals方法</p><ol><li><p>Object类中的equals</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   obj   the reference object with which to compare.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  &#123;<span class="doctag">@code</span> true&#125; if this object is the same as the obj</span></span><br><span class="line"><span class="comment"> *          argument; &#123;<span class="doctag">@code</span> false&#125; otherwise.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     #hashCode()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.util.HashMap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阅读源码发现，比较的是当前对象的引用和obj的引用是否相同，也就是说<strong>默认比较的是地址</strong>。</p><p>其中<strong>return (this == obj);</strong> 使用的也是<strong>“==”</strong>进行判断，所以，在这里 <strong>==</strong> 比较的是引用的地址，而<strong>equals</strong>也是比较的引用的地址，所以，<strong>==</strong>和<strong>equals</strong>在这里的效果是一样的，都是比较引用的地址。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">User user1 = <span class="keyword">new</span> User(<span class="string">"张三"</span>, <span class="number">20</span>);</span><br><span class="line">    User user2 = <span class="keyword">new</span> User(<span class="string">"张三"</span>, <span class="number">20</span>);</span><br><span class="line"><span class="comment">//  比较的是普通对象User，==和equals的作用是一样的</span></span><br><span class="line">    System.out.println(user1 == user2);<span class="comment">//输出结果：false</span></span><br><span class="line">System.out.println(user1.equals(user2));<span class="comment">//输出结果：false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>String类中的equals</p><p>Object对象里的 == 和 equals 没什么区别，意义不大，所以String在Object的基础上重写了equals。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  anObject</span></span><br><span class="line"><span class="comment"> *         The object to compare this &#123;<span class="doctag">@code</span> String&#125; against</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  &#123;<span class="doctag">@code</span> true&#125; if the given object represents a &#123;<span class="doctag">@code</span> String&#125;</span></span><br><span class="line"><span class="comment"> *          equivalent to this string, &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>  #compareTo(String)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>  #equalsIgnoreCase(String)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将此字符串与指定对象进行比较。当且仅当参数不是 null 且是一个 String 对象，表示与此对象相同的字符序列时，结果为 true 。</p><p>String类中的equals方法比较的是字符串内容是否一致。</p><p>注意：像String、Date这些重写了equals的类，使用的时候会与Object类的equals不一样</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str1 = <span class="string">"Hello"</span>;</span><br><span class="line">    String str2 = <span class="keyword">new</span> String(<span class="string">"Hello"</span>);</span><br><span class="line">    String str3 = str2;</span><br><span class="line"></span><br><span class="line">    System.out.println(str1 == str2);       <span class="comment">//输出结果：false</span></span><br><span class="line">    System.out.println(str1 == str3);       <span class="comment">//输出结果：false</span></span><br><span class="line">    System.out.println(str2 == str3);       <span class="comment">//输出结果：true</span></span><br><span class="line">    System.out.println(str1.equals(str2));  <span class="comment">//输出结果：true</span></span><br><span class="line">    System.out.println(str1.equals(str3));  <span class="comment">//输出结果：true</span></span><br><span class="line">    System.out.println(str2.equals(str3));  <span class="comment">//输出结果：true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>内存解释</p><p>在Java中，一般把对象放在堆区，对象的引用放在栈区。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/SevenKiss/imgPicGo/image/20200704025413.png" alt=""></p><p>3.1    String str1 = “Hello”; 是在堆区存放一个字符串对象<br>3.2    String str2 = new String(“Hello”); 是在堆区重新存放一个字符串对象</p><p>3.3    String str3 = str2;    这个时候str3和str2是不同的引用，但指向的是同一个字符串对象</p></li></ol><ol start="4"><li><p>总结</p><ol><li>基础类型比较</li></ol><p>使用 <strong>==</strong> 比较值是否相等</p><ol start="2"><li><p>引用类型比较</p><ol start="3"><li><p>重写了equals方法，比如String、Date</p><p>第一种情况：使用 == 比较的是String的引用是否指向同一内存地址</p><p>第二种情况：使用 equals 比较的是String的引用的对象内容是否相同</p></li><li><p>没有重写equals方法，比如自定义类User</p><p>== 和 equals 比较的都是引用是否指向同一内存地址</p></li></ol></li><li><p>特例</p><p>String类型中，会有一个小问题</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str1 = <span class="string">"Hello"</span>;</span><br><span class="line">    String str2 = <span class="keyword">new</span> String(<span class="string">"Hello"</span>);</span><br><span class="line">    str2 = str2.intern();</span><br><span class="line"></span><br><span class="line">    System.out.println(str1 == str2);       <span class="comment">//true</span></span><br><span class="line">    System.out.println(str1.equals(str2));  <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用intern方法时，如果池中已经包含一个由 equals(Object) 方法确定的等于此 String 对象的字符串，则返回来自池的字符串。否则，将此 String 对象添加到池中，并返回对此String 对象的引用。</p><p>意思就是检查字符串池里是否存在，如果存在，就用池里的字符串对象，如果不存在，就重新添加</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次Vue面试</title>
      <link href="/2020/06/12/%E8%AE%B0%E4%B8%80%E6%AC%A1Vue%E9%9D%A2%E8%AF%95/"/>
      <url>/2020/06/12/%E8%AE%B0%E4%B8%80%E6%AC%A1Vue%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/SevenKiss/imgPicGo/image/20200704034032.png" alt=""></p><h2 id="什么是钩子函数"><a href="#什么是钩子函数" class="headerlink" title="什么是钩子函数"></a>什么是钩子函数</h2><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/SevenKiss/imgPicGo/image/20200704034112.png" alt=""></p><p>关键字：<strong>在系统级对所有消息和事件进行过滤</strong></p><p>​                是说钩子函数是在一个事件触发的时候，在系统级捕获到了它，然后做一些操作。</p><p>关键字：<strong>一段用以处理系统消息的程序</strong></p><p>​                钩子函数是用来处理系统消息的</p><p>总结：</p><p>​        1、钩子函数，顾名思义是个函数，在系统消息触发时被系统调用</p><p>​        2、 不是用户自己触发的</p><h2 id="常见的钩子函数"><a href="#常见的钩子函数" class="headerlink" title="常见的钩子函数"></a>常见的钩子函数</h2><h3 id="React的生命周期函数"><a href="#React的生命周期函数" class="headerlink" title="React的生命周期函数"></a>React的生命周期函数</h3><h3 id="Vue的生命周期函数"><a href="#Vue的生命周期函数" class="headerlink" title="Vue的生命周期函数"></a>Vue的生命周期函数</h3><h2 id="Vue的双向绑定"><a href="#Vue的双向绑定" class="headerlink" title="Vue的双向绑定"></a>Vue的双向绑定</h2><h3 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h3><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/SevenKiss/imgPicGo/image/20200704034238.png" alt=""></p><p>以往的MVC模式是单向绑定，即Model绑定到View，当我们用JavaScript代码更新Model时，View就会自动更新 </p><pre><code>### 1.3.1、MVVM模式</code></pre><p>​        说到Vue的双向绑定首先联系到的就是MVVM(Model-View-ViewModel)模式了，如下图所示，当试图发生改变的时候传递给VM,再让数据得到更新，当数据发生改变的时候传给VM,使得试图发生改变；</p><p>​        MVVM模式是通过以下三个核心组件组成，每个都有它自己独特的角色：</p><p>​            <strong>Model</strong> - 包含了业务和验证逻辑的数据模型</p><p>​            <strong>View</strong> - 定义屏幕中View的结构，布局和外观</p><p>​            <strong>ViewModel</strong> - 扮演“View”和“Model”之间的使者，帮忙处理 <strong>View</strong> 的全部业务逻辑 </p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/SevenKiss/imgPicGo/image/20200704034318.png" alt=""></p><pre><code>### 1.3.2、Vue数据双向绑定原理</code></pre><p>​        Vue的双向绑定主要通过 <strong>Object.defineProperty()</strong> 方法来进行<strong>数据劫持</strong>以及<strong>发布者-订阅</strong>模式来实现的。</p><p>​        1、 Vue是怎么实现数据劫持的？</p><p>​                Vue实例化的时候会去遍历所有属性，给这些属性添加get和set方法进行数据劫持</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/SevenKiss/imgPicGo/image/20200704034342.png" alt=""></p><h3 id="双向绑定的具体实现？"><a href="#双向绑定的具体实现？" class="headerlink" title="双向绑定的具体实现？"></a>双向绑定的具体实现？</h3><p>​    1、实现一个监听器Observer，用来劫持并监听所有属性，如果有变动，就通知订阅者。</p><p>​    2、实现一个订阅者Watcher，每一个Watcher都绑定一个更新函数，Watcher可以收到属性的变化通知并执行响应的函数，从而更新视图。</p><p>​    3、实现一个解析器Compile，可以扫描和解析每个节点的相关指令（v-model、v-on等指令），如果节点存在v-model, v-on等指令，则解析器Compile初始化这类节点的模板数据，使之可以显示在视图上，然后初始化相应的订阅者Watcher</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/SevenKiss/imgPicGo/image/20200704034345.png" alt=""></p><h2 id="Vue中class的用法"><a href="#Vue中class的用法" class="headerlink" title="Vue中class的用法"></a>Vue中class的用法</h2><p>​    Vue中的class有 4 种写法，class和style都属于DOM属性，所以在Vue中使用 :class 和 :style表示</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--要给id为app的元素添加属性--&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .green&#123;color:green&#125;</span><br><span class="line">    .red&#123;background-color:red&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--方法一--&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;!--结果为绿色字体，红色背景--&gt;</span><br><span class="line">&lt;span :class&#x3D;&quot;[greens,reds]&quot;&gt;在Vue中使用class&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;!--注意，此处需要自行引入vue.js文件--&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;.&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;scipt&gt;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: &quot;#app&quot;,</span><br><span class="line">    data:&#123;</span><br><span class="line">    greens:&quot;green&quot;,</span><br><span class="line">    reds:&quot;red&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;scipt&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--方法二--&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;!--结果为绿色字体，背景不是红色--&gt;</span><br><span class="line">&lt;span :class&#x3D;&quot;&#123;green:true,red:false&#125;&quot;&gt;在Vue中使用class&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;.&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;scipt&gt;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: &quot;#app&quot;,</span><br><span class="line">    data:&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;scipt&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--方法三--&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;!--结果为默认颜色字体，背景是红色--&gt;</span><br><span class="line">&lt;span :class&#x3D;&quot;demo&quot;&gt;在Vue中使用class&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;.&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;scipt&gt;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: &quot;#app&quot;,</span><br><span class="line">    data:&#123;</span><br><span class="line">    demo:&#123;</span><br><span class="line">    green:false,</span><br><span class="line">    red:true</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;scipt&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--方法四--&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;!--结果为绿色字体，背景是红色--&gt;</span><br><span class="line">&lt;span :class&#x3D;&quot;&#123;green:g,red:r&#125;&quot;&gt;在Vue中使用class&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;.&#x2F;node_modules&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;scipt&gt;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: &quot;#app&quot;,</span><br><span class="line">    data:&#123;</span><br><span class="line">    demo:&#123;</span><br><span class="line">    g:true,</span><br><span class="line">    r:true</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;scipt&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
